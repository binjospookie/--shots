"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      files = _ref.files,
      code = _ref.code,
      codeFilename = _ref.codeFilename,
      config = _ref.config,
      configFile = _ref.configFile,
      configBasedir = _ref.configBasedir,
      configOverrides = _ref.configOverrides,
      ignoreDisables = _ref.ignoreDisables,
      ignorePath = _ref.ignorePath,
      reportNeedlessDisables = _ref.reportNeedlessDisables,
      formatter = _ref.formatter,
      syntax = _ref.syntax,
      customSyntax = _ref.customSyntax;

  var isValidCode = typeof code === "string";
  if (!files && !isValidCode || files && (code || isValidCode)) {
    throw new Error("You must pass stylelint a `files` glob or a `code` string, though not both");
  }

  var formatterFunction = void 0;
  if (typeof formatter === "string") {
    formatterFunction = formatters[formatter];
    if (formatterFunction === undefined) {
      return Promise.reject(new Error("You must use a valid formatter option: 'json', 'string', 'verbose', or a function"));
    }
  } else if (typeof formatter === "function") {
    formatterFunction = formatter;
  } else {
    formatterFunction = formatters.json;
  }

  var stylelint = (0, _createStylelint2.default)({
    config: config,
    configFile: configFile,
    configBasedir: configBasedir,
    configOverrides: configOverrides,
    ignoreDisables: ignoreDisables,
    ignorePath: ignorePath,
    reportNeedlessDisables: reportNeedlessDisables,
    syntax: syntax,
    customSyntax: customSyntax
  });

  if (!files) {
    return stylelint._lintSource({ code: code, codeFilename: codeFilename }).then(function (postcssResult) {
      return stylelint._createStylelintResult(postcssResult);
    }).catch(handleError).then(function (stylelintResult) {
      return prepareReturnValue([stylelintResult]);
    });
  }

  return (0, _globby2.default)([].concat(files, alwaysIgnoredGlobs)).then(function (filePaths) {
    if (!filePaths.length) {
      var err = new Error("Files glob patterns specified did not match any files");
      err.code = 80;
      throw err;
    }

    var getStylelintResults = filePaths.map(function (filePath) {
      return stylelint._lintSource({ filePath: filePath }).then(function (postcssResult) {
        return stylelint._createStylelintResult(postcssResult, filePath);
      }).catch(handleError);
    });

    return Promise.all(getStylelintResults);
  }).then(prepareReturnValue);

  function prepareReturnValue(stylelintResults) {
    var errored = stylelintResults.some(function (result) {
      return result.errored;
    });
    var returnValue = {
      errored: errored,
      output: formatterFunction(stylelintResults),
      results: stylelintResults
    };
    if (reportNeedlessDisables) {
      returnValue.needlessDisables = (0, _needlessDisables2.default)(stylelintResults);
    }
    return returnValue;
  }
};

var _formatters = require("./formatters");

var formatters = _interopRequireWildcard(_formatters);

var _createStylelint = require("./createStylelint");

var _createStylelint2 = _interopRequireDefault(_createStylelint);

var _globby = require("globby");

var _globby2 = _interopRequireDefault(_globby);

var _needlessDisables = require("./needlessDisables");

var _needlessDisables2 = _interopRequireDefault(_needlessDisables);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var alwaysIgnoredGlobs = ["!**/node_modules/**", "!**/bower_components/**"];

function handleError(error) {
  if (error.name === "CssSyntaxError") {
    return convertCssSyntaxErrorToResult(error);
  } else {
    throw error;
  }
}

// By converting syntax errors to stylelint results,
// we can control their appearance in the formatted output
// and other tools like editor plugins can decide how to
// present them, as well
function convertCssSyntaxErrorToResult(error) {
  if (error.name !== "CssSyntaxError") {
    throw error;
  }

  return {
    source: error.file || "<input css 1>",
    deprecations: [],
    invalidOptionWarnings: [],
    errored: true,
    warnings: [{
      line: error.line,
      column: error.column,
      rule: error.name,
      severity: "error",
      text: error.reason + " (" + error.name + ")"
    }]
  };
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findFontFamily;

var _keywordSets = require("../reference/keywordSets");

var _ = require("./");

var _postcssValueParser = require("postcss-value-parser");

var _postcssValueParser2 = _interopRequireDefault(_postcssValueParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nodeTypesToCheck = new Set(["word", "string", "space", "div"]);

function joinValueNodes(firstNode, secondNode, charactersBetween) {
  firstNode.value = firstNode.value + charactersBetween + secondNode.value;

  return firstNode;
}

/**
 * Get the font-families within a `font` shorthand property value.
 *
 * @param {string} value
 * @return {object} Collection font-family nodes
 */
function findFontFamily(value) {
  var fontFamilies = [];

  var valueNodes = (0, _postcssValueParser2.default)(value);

  // Handle `inherit`, `initial` and etc
  if (valueNodes.nodes.length === 1 && _keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase())) {
    return [valueNodes.nodes[0]];
  }

  var needMergeNodesByValue = false;
  var mergeCharacters = null;

  valueNodes.walk(function (valueNode, index, nodes) {
    if (valueNode.type === "function") {
      return false;
    }
    if (!nodeTypesToCheck.has(valueNode.type)) {
      return;
    }

    var valueLowerCase = valueNode.value.toLowerCase();

    // Ignore non standard syntax
    if (!(0, _.isStandardSyntaxValue)(valueLowerCase)) {
      return;
    }

    // Ignore variables
    if ((0, _.isVariable)(valueLowerCase)) {
      return;
    }

    // Ignore keywords for other font parts
    if (_keywordSets.fontShorthandKeywords.has(valueLowerCase) && !_keywordSets.fontFamilyKeywords.has(valueLowerCase)) {
      return;
    }

    // Ignore font-sizes
    if ((0, _.isValidFontSize)(valueNode.value)) {
      return;
    }

    // Ignore anything come after a <font-size>/, because it's a line-height
    if (nodes[index - 1] && nodes[index - 1].value === "/" && nodes[index - 2] && (0, _.isValidFontSize)(nodes[index - 2].value)) {
      return;
    }

    // Ignore number values
    if ((0, _.isNumbery)(valueLowerCase)) {
      return;
    }

    // Detect when a space or comma is dividing a list of font-families, and save the joining character.
    if ((valueNode.type === "space" || valueNode.type === "div" && valueNode.value !== ",") && fontFamilies.length !== 0) {
      needMergeNodesByValue = true;
      mergeCharacters = valueNode.value;
      return;
    } else if (valueNode.type === "space" || valueNode.type === "div") {
      return;
    }

    var fontFamily = valueNode;

    if (needMergeNodesByValue) {
      joinValueNodes(fontFamilies[fontFamilies.length - 1], valueNode, mergeCharacters);
      needMergeNodesByValue = false;
      mergeCharacters = null;
    } else {
      fontFamilies.push(fontFamily);
    }
  });

  return fontFamilies;
}
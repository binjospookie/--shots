"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (results) {
  var report = [];

  results.forEach(function (result) {
    // File with `CssSyntaxError` have not `_postcssResult`
    if (!result._postcssResult) {
      return;
    }

    var unused = { source: result.source, ranges: [] };
    var rangeData = _lodash2.default.cloneDeep(result._postcssResult.stylelint.disabledRanges);

    if (!rangeData) {
      return;
    }

    result.warnings.forEach(function (warning) {
      var rule = warning.rule;


      var ruleRanges = rangeData[rule];
      if (ruleRanges) {
        // Back to front so we get the *last* range that applies to the warning
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = ruleRanges.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var range = _step.value;

            if (isWarningInRange(warning, range)) {
              range.used = true;
              return;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = rangeData.all.reverse()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _range = _step2.value;

          if (isWarningInRange(warning, _range)) {
            _range.used = true;
            return;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    });

    Object.keys(rangeData).forEach(function (rule) {
      rangeData[rule].forEach(function (range) {
        // Is an equivalent range already marked as unused?
        var alreadyMarkedUnused = unused.ranges.find(function (unusedRange) {
          return unusedRange.start === range.start && unusedRange.end === range.end;
        });

        // If this range is unused and no equivalent is marked,
        // mark this range as unused
        if (!range.used && !alreadyMarkedUnused) {
          unused.ranges.push(range);
        }

        // If this range is used but an equivalent has been marked as unused,
        // remove that equivalent. This can happen because of the duplication
        // of ranges in rule-specific range sets and the "all" range set
        if (range.used && alreadyMarkedUnused) {
          _lodash2.default.remove(unused.ranges, alreadyMarkedUnused);
        }
      });
    });

    unused.ranges = _lodash2.default.sortBy(unused.ranges, ["start", "end"]);

    report.push(unused);
  });

  return report;
};

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* flow */
function isWarningInRange(warning, range) {
  var rule = warning.rule,
      line = warning.line;

  return range.start <= line && (range.end >= line || range.end === undefined) && (!range.rules || range.rules.indexOf(rule) !== -1);
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.messages = exports.ruleName = undefined;

exports.default = function (expectation, options) {
  return function (root, result) {
    var validOptions = (0, _utils.validateOptions)(result, ruleName, {
      actual: expectation,
      possible: ["always", "never", "always-multi-line", "never-multi-line"]
    }, {
      actual: options,
      possible: {
        ignore: ["after-comment"],
        except: ["after-single-line-comment"]
      },
      optional: true
    });
    if (!validOptions) {
      return;
    }

    root.walkRules(function (rule) {
      if (!(0, _utils.isStandardSyntaxRule)(rule)) {
        return;
      }

      // Ignore nested rule sets
      if (rule.parent !== root) {
        return;
      }

      // Ignore the first node
      if (rule === root.first) {
        return;
      }

      checkRuleEmptyLineBefore({ rule: rule, expectation: expectation, options: options, result: result, messages: messages, checkedRuleName: ruleName });
    });
  };
};

exports.checkRuleEmptyLineBefore = checkRuleEmptyLineBefore;

var _utils = require("../../utils");

var ruleName = exports.ruleName = "rule-non-nested-empty-line-before";

var messages = exports.messages = (0, _utils.ruleMessages)(ruleName, {
  expected: "Expected empty line before non-nested rule",
  rejected: "Unexpected empty line before non-nested rule"
});

function checkRuleEmptyLineBefore(_ref) {
  var rule = _ref.rule,
      expectation = _ref.expectation,
      options = _ref.options,
      result = _ref.result,
      messages = _ref.messages,
      checkedRuleName = _ref.checkedRuleName;

  var expectEmptyLineBefore = expectation.indexOf("always") !== -1 ? true : false;

  // Optionally ignore the expectation if a comment precedes this node
  if ((0, _utils.optionsMatches)(options, "ignore", "after-comment") && rule.prev() && rule.prev().type === "comment") {
    return;
  }

  // Ignore if the expectation is for multiple and the rule is single-line
  if (expectation.indexOf("multi-line") !== -1 && (0, _utils.isSingleLineString)(rule.toString())) {
    return;
  }

  // Optionally reverse the expectation for the first nested node
  if ((0, _utils.optionsMatches)(options, "except", "first-nested") && rule === rule.parent.first) {
    expectEmptyLineBefore = !expectEmptyLineBefore;
  }

  // Optionally reverse the expectation for single line comments
  if ((0, _utils.optionsMatches)(options, "except", "after-single-line-comment") && rule.prev() && rule.prev().type === "comment" && (0, _utils.isSingleLineString)(rule.prev().toString())) {
    expectEmptyLineBefore = !expectEmptyLineBefore;
  }

  var hasEmptyLineBefore = (0, _utils.hasEmptyLine)(rule.raws.before);

  // Return if the expectation is met
  if (expectEmptyLineBefore === hasEmptyLineBefore) {
    return;
  }

  var message = expectEmptyLineBefore ? messages.expected : messages.rejected;

  (0, _utils.report)({
    message: message,
    node: rule,
    result: result,
    ruleName: checkedRuleName
  });
}
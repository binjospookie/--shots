"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (stylelint) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var cached = stylelint._postcssResultCache.get(options.filePath);
  if (cached) return Promise.resolve(cached);

  var getCode = void 0;
  if (options.code !== undefined) {
    getCode = Promise.resolve(options.code);
  } else if (options.filePath) {
    getCode = readFile(options.filePath);
  }

  if (!getCode) {
    throw new Error("code or filePath required");
  }

  return getCode.then(function (code) {
    var customSyntax = stylelint._options.customSyntax;
    var syntax = stylelint._options.syntax;

    if (customSyntax) {
      try {
        syntax = require(customSyntax);
      } catch (e) {
        throw new Error("Cannot resolve custom syntax module " + customSyntax);
      }
    } else {
      var fileExtension = _path2.default.extname(options.filePath || "");
      if (syntax === "scss" || !syntax && fileExtension === ".scss") {
        syntax = _postcssScss2.default;
      } else if (syntax === "less" || !syntax && fileExtension === ".less") {
        syntax = _postcssLess2.default;
      } else if (syntax === "sugarss" || !syntax && fileExtension === ".sss") {
        syntax = _sugarss2.default;
      } else if (syntax) {
        throw new Error("You must use a valid syntax option, either: scss, less or sugarss");
      }
    }

    var postcssOptions = {};

    postcssOptions.from = options.filePath;

    /*
     * PostCSS allows for syntaxes that only contain a parser, however,
     * it then expects the syntax to be set as the `parser` option rather than `syntax.
     */
    if (syntax && !syntax.stringify) {
      postcssOptions.parser = syntax;
    } else {
      postcssOptions.syntax = syntax;
    }

    var source = options.code ? options.codeFilename : options.filePath;
    var preProcessedCode = code;
    if (options.codeProcessors) {
      options.codeProcessors.forEach(function (codeProcessor) {
        preProcessedCode = codeProcessor(preProcessedCode, source);
      });
    }

    return postcssProcessor.process(preProcessedCode, postcssOptions);
  }).then(function (postcssResult) {
    stylelint._postcssResultCache.set(options.filePath, postcssResult);
    return postcssResult;
  });
};

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _postcssLess = require("postcss-less");

var _postcssLess2 = _interopRequireDefault(_postcssLess);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssScss = require("postcss-scss");

var _postcssScss2 = _interopRequireDefault(_postcssScss);

var _sugarss = require("sugarss");

var _sugarss2 = _interopRequireDefault(_sugarss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var postcssProcessor = (0, _postcss2.default)();

function readFile(filePath) {
  return new Promise(function (resolve, reject) {
    _fs2.default.readFile(filePath, "utf8", function (err, content) {
      if (err) {
        return reject(err);
      }
      resolve(content);
    });
  });
}
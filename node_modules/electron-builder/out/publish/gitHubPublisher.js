"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GitHubPublisher = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

var _util;

function _load_util() {
    return _util = require("../util/util");
}

var _log;

function _load_log() {
    return _log = require("../util/log");
}

var _url;

function _load_url() {
    return _url = require("url");
}

var _mime;

function _load_mime() {
    return _mime = _interopRequireDefault(require("mime"));
}

var _restApiRequest;

function _load_restApiRequest() {
    return _restApiRequest = require("./restApiRequest");
}

var _publisher;

function _load_publisher() {
    return _publisher = require("./publisher");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GitHubPublisher extends (_publisher || _load_publisher()).Publisher {
    constructor(info, version) {
        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        let isPublishOptionGuessed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        super();
        this.info = info;
        this.version = version;
        this.options = options;
        this.isPublishOptionGuessed = isPublishOptionGuessed;
        let token = info.token;
        if ((0, (_util || _load_util()).isEmptyOrSpaces)(token)) {
            token = process.env.GH_TOKEN;
            if ((0, (_util || _load_util()).isEmptyOrSpaces)(token)) {
                throw new Error(`GitHub Personal Access Token is not set, neither programmatically, nor using env "GH_TOKEN"`);
            }
        }
        this.token = token;
        this.options = options || {};
        this.policy = this.options.publish || "always";
        if (version.startsWith("v")) {
            throw new Error(`Version must not starts with "v": ${ version }`);
        }
        this.tag = info.vPrefixedTagName === false ? version : `v${ version }`;
        this._releasePromise = this.token === "__test__" ? (_bluebirdLstC2 || _load_bluebirdLstC2()).default.resolve(null) : this.init();
    }
    get releasePromise() {
        return this._releasePromise;
    }
    init() {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const createReleaseIfNotExists = _this.policy !== "onTagOrDraft";
            // we don't use "Get a release by tag name" because "tag name" means existing git tag, but we draft release and don't create git tag
            const releases = yield (0, (_restApiRequest || _load_restApiRequest()).githubRequest)(`/repos/${ _this.info.owner }/${ _this.info.repo }/releases`, _this.token);
            for (let release of releases) {
                if (release.tag_name === _this.tag || release.tag_name === _this.version) {
                    if (release.draft) {
                        return release;
                    }
                    if (!_this.isPublishOptionGuessed && _this.policy === "onTag") {
                        throw new Error(`Release with tag ${ _this.tag } must be a draft`);
                    }
                    const message = `Release with tag ${ _this.tag } is not a draft, artifacts will be not published`;
                    if (_this.isPublishOptionGuessed || _this.policy === "onTagOrDraft") {
                        (0, (_log || _load_log()).log)(message);
                    } else {
                        (0, (_log || _load_log()).warn)(message);
                    }
                    return null;
                }
            }
            if (createReleaseIfNotExists) {
                (0, (_log || _load_log()).log)(`Release with tag ${ _this.tag } doesn't exist, creating one`);
                return _this.createRelease();
            } else {
                (0, (_log || _load_log()).log)(`Release with tag ${ _this.tag } doesn't exist, artifacts will be not published`);
                return null;
            }
        })();
    }
    doUpload(fileName, dataLength, requestProcessor) {
        var _this2 = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const release = yield _this2.releasePromise;
            if (release == null) {
                (0, (_util || _load_util()).debug)(`Release with tag ${ _this2.tag } doesn't exist and is not created, artifact ${ fileName } is not published`);
                return;
            }
            const parsedUrl = (0, (_url || _load_url()).parse)(release.upload_url.substring(0, release.upload_url.indexOf("{")) + "?name=" + fileName);
            let badGatewayCount = 0;
            uploadAttempt: for (let i = 0; i < 3; i++) {
                try {
                    return yield (0, (_restApiRequest || _load_restApiRequest()).doApiRequest)({
                        hostname: parsedUrl.hostname,
                        path: parsedUrl.path,
                        method: "POST",
                        headers: {
                            Accept: "application/vnd.github.v3+json",
                            "User-Agent": "electron-builder",
                            "Content-Type": (_mime || _load_mime()).default.lookup(fileName),
                            "Content-Length": dataLength
                        }
                    }, _this2.token, requestProcessor);
                } catch (e) {
                    if (e instanceof (_restApiRequest || _load_restApiRequest()).HttpError) {
                        if (e.response.statusCode === 422 && e.description != null && e.description.errors != null && e.description.errors[0].code === "already_exists") {
                            // delete old artifact and re-upload
                            (0, (_log || _load_log()).log)(`Artifact ${ fileName } already exists, overwrite one`);
                            const assets = yield (0, (_restApiRequest || _load_restApiRequest()).githubRequest)(`/repos/${ _this2.info.owner }/${ _this2.info.repo }/releases/${ release.id }/assets`, _this2.token);
                            for (let asset of assets) {
                                if (asset.name === fileName) {
                                    yield (0, (_restApiRequest || _load_restApiRequest()).githubRequest)(`/repos/${ _this2.info.owner }/${ _this2.info.repo }/releases/assets/${ asset.id }`, _this2.token, null, "DELETE");
                                    continue uploadAttempt;
                                }
                            }
                            (0, (_log || _load_log()).log)(`Artifact ${ fileName } not found, trying to upload again`);
                            continue;
                        } else if (e.response.statusCode === 502 && badGatewayCount++ < 3) {
                            continue;
                        }
                    }
                    throw e;
                }
            }
        })();
    }
    createRelease() {
        return (0, (_restApiRequest || _load_restApiRequest()).githubRequest)(`/repos/${ this.info.owner }/${ this.info.repo }/releases`, this.token, {
            tag_name: this.tag,
            name: this.version,
            draft: this.options.draft == null || this.options.draft,
            prerelease: this.options.prerelease != null && this.options.prerelease
        });
    }
    // test only
    //noinspection JSUnusedGlobalSymbols
    getRelease() {
        var _this3 = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            return (0, (_restApiRequest || _load_restApiRequest()).githubRequest)(`/repos/${ _this3.info.owner }/${ _this3.info.repo }/releases/${ (yield _this3._releasePromise).id }`, _this3.token);
        })();
    }
    //noinspection JSUnusedGlobalSymbols
    deleteRelease() {
        var _this4 = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const release = yield _this4._releasePromise;
            if (release == null) {
                return;
            }
            for (let i = 0; i < 3; i++) {
                try {
                    return yield (0, (_restApiRequest || _load_restApiRequest()).githubRequest)(`/repos/${ _this4.info.owner }/${ _this4.info.repo }/releases/${ release.id }`, _this4.token, null, "DELETE");
                } catch (e) {
                    if (e instanceof (_restApiRequest || _load_restApiRequest()).HttpError) {
                        if (e.response.statusCode === 404) {
                            (0, (_log || _load_log()).warn)(`Cannot delete release ${ release.id } â€” doesn't exist`);
                            return;
                        } else if (e.response.statusCode === 405 || e.response.statusCode === 502) {
                            continue;
                        }
                    }
                    throw e;
                }
            }
            (0, (_log || _load_log()).warn)(`Cannot delete release ${ release.id }`);
        })();
    }
}
exports.GitHubPublisher = GitHubPublisher; //# sourceMappingURL=gitHubPublisher.js.map
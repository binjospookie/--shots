"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rebuild = exports.installOrRebuild = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

let installOrRebuild = exports.installOrRebuild = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (options, appDir, electronVersion, arch) {
        let forceInstall = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        const args = computeExtraArgs(options);
        if (forceInstall || !(yield (0, (_util || _load_util()).exists)(_path.join(appDir, "node_modules")))) {
            yield installDependencies(appDir, electronVersion, arch, args);
        } else {
            yield rebuild(appDir, electronVersion, arch, args);
        }
    });

    return function installOrRebuild(_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
    };
})();

let rebuild = exports.rebuild = (() => {
    var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (appDir, electronVersion) {
        let arch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.arch;
        let additionalArgs = arguments[3];

        const deps = new Set();
        yield dependencies(appDir, false, deps);
        const nativeDeps = yield (_bluebirdLstC2 || _load_bluebirdLstC2()).default.filter(deps, function (it) {
            return (0, (_util || _load_util()).exists)(_path.join(it, "binding.gyp"));
        }, { concurrency: 8 });
        if (nativeDeps.length === 0) {
            return;
        }
        (0, (_log || _load_log()).log)(`Rebuilding native production dependencies for arch ${ arch }`);
        let execPath = process.env.npm_execpath || process.env.NPM_CLI_JS;
        const execArgs = [];
        if (execPath == null) {
            execPath = getPackageToolPath();
        } else {
            execArgs.push(execPath);
            execPath = process.env.npm_node_execpath || process.env.NODE_EXE || "node";
        }
        const env = getGypEnv(electronVersion, arch);
        if (isYarnPath(execPath)) {
            execArgs.push("run", "install", "--");
            execArgs.push("--disturl=https://atom.io/download/electron");
            execArgs.push(`--target=${ electronVersion }`);
            execArgs.push("--runtime=electron");
            execArgs.push(`--arch=${ arch }`);
            execArgs.push.apply(execArgs, _toConsumableArray(additionalArgs));
            yield (_bluebirdLstC2 || _load_bluebirdLstC2()).default.each(nativeDeps, function (it) {
                return (0, (_util || _load_util()).spawn)(execPath, execArgs, { cwd: it, env: env });
            });
        } else {
            execArgs.push("rebuild");
            execArgs.push.apply(execArgs, _toConsumableArray(additionalArgs));
            execArgs.push.apply(execArgs, _toConsumableArray(nativeDeps.map(function (it) {
                return _path.basename(it);
            })));
            yield (0, (_util || _load_util()).spawn)(execPath, execArgs, { cwd: appDir, env: env });
        }
    });

    return function rebuild(_x8, _x9, _x10, _x11) {
        return _ref2.apply(this, arguments);
    };
})();
//# sourceMappingURL=yarn.js.map


exports.getGypEnv = getGypEnv;
exports.installDependencies = installDependencies;
exports.dependencies = dependencies;

var _path = _interopRequireWildcard(require("path"));

var _log;

function _load_log() {
    return _log = require("./util/log");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _util;

function _load_util() {
    return _util = require("./util/util");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function getGypEnv(electronVersion, arch) {
    const gypHome = _path.join((0, (_os || _load_os()).homedir)(), ".electron-gyp");
    return Object.assign({}, process.env, {
        npm_config_disturl: "https://atom.io/download/electron",
        npm_config_target: electronVersion,
        npm_config_runtime: "electron",
        npm_config_arch: arch,
        HOME: gypHome,
        USERPROFILE: gypHome
    });
}
function computeExtraArgs(options) {
    const args = (0, (_util || _load_util()).asArray)(options.npmArgs);
    if (options.npmSkipBuildFromSource !== true) {
        args.push("--build-from-source");
    }
    return args;
}
function installDependencies(appDir, electronVersion) {
    let arch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.arch;
    let additionalArgs = arguments[3];

    (0, (_log || _load_log()).log)(`Installing app dependencies for arch ${ arch } to ${ appDir }`);
    let execPath = process.env.npm_execpath || process.env.NPM_CLI_JS;
    const execArgs = ["install", "--production"];
    const isYarn = isYarnPath(execPath);
    if (!isYarn) {
        if (process.env.NPM_NO_BIN_LINKS === "true") {
            execArgs.push("--no-bin-links");
        }
        execArgs.push("--cache-min", "999999999");
    }
    if (execPath == null) {
        execPath = getPackageToolPath();
    } else {
        execArgs.unshift(execPath);
        execPath = process.env.npm_node_execpath || process.env.NODE_EXE || "node";
    }
    for (let a of additionalArgs) {
        if (!isYarn || a !== "--build-from-source") {
            execArgs.push(a);
        }
    }
    return (0, (_util || _load_util()).spawn)(execPath, execArgs, {
        cwd: appDir,
        env: getGypEnv(electronVersion, arch)
    });
}
let readInstalled = null;
function dependencies(dir, extraneousOnly, result) {
    if (readInstalled == null) {
        readInstalled = (_bluebirdLstC2 || _load_bluebirdLstC2()).default.promisify(require("read-installed"));
    }
    return readInstalled(dir).then(it => flatDependencies(it, result, new Set(), extraneousOnly));
}
function flatDependencies(data, result, seen, extraneousOnly) {
    if (data.dependencies == null) {
        return;
    }
    const queue = [data.dependencies];
    while (queue.length > 0) {
        const deps = queue.pop();
        for (let name of Object.keys(deps)) {
            const dep = deps[name];
            if (typeof dep !== "object" || !extraneousOnly && dep.extraneous || seen.has(dep)) {
                continue;
            }
            seen.add(dep);
            if (extraneousOnly === dep.extraneous) {
                result.add(dep.path);
            } else {
                const childDeps = dep.dependencies;
                if (childDeps != null) {
                    queue.push(childDeps);
                }
            }
        }
    }
}
function getPackageToolPath() {
    if (process.env.FORCE_YARN === "true") {
        return process.platform === "win32" ? "yarn.cmd" : "yarn";
    } else {
        return process.platform === "win32" ? "npm.cmd" : "npm";
    }
}
function isYarnPath(execPath) {
    return execPath != null && _path.basename(execPath).startsWith("yarn");
}
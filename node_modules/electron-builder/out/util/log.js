"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.warn = warn;
exports.log = log;
exports.subTask = subTask;
exports.task = task;

var _chalk;

function _load_chalk() {
    return _chalk = require("chalk");
}

var _ansiEscapes;

function _load_ansiEscapes() {
    return _ansiEscapes = require("ansi-escapes");
}

var _cliCursor;

function _load_cliCursor() {
    return _cliCursor = _interopRequireWildcard(require("cli-cursor"));
}

var _prettyMs;

function _load_prettyMs() {
    return _prettyMs = _interopRequireDefault(require("pretty-ms"));
}

var _nodeEmoji;

function _load_nodeEmoji() {
    return _nodeEmoji = require("node-emoji");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class SimpleLine {
    //noinspection JSUnusedGlobalSymbols
    constructor(text, promise) {
        this.text = text;
        this.promise = promise;
    }
}
class Task {
    constructor(text, rawText, promise) {
        this.text = text;
        this.rawText = rawText;
        this.promise = promise;
        this.start = process.hrtime();
    }
    done() {
        const duration = process.hrtime(this.start);
        const ms = duration[0] * 1000 + duration[1] / 1e6;
        this.text = `${ this.rawText } ${ (0, (_chalk || _load_chalk()).green)((0, (_prettyMs || _load_prettyMs()).default)(ms)) }\n`;
    }
}
class Logger {
    constructor(stream) {
        this.stream = stream;
        this.lines = [];
        this.logTime = process.env.LOG_TIME === "true";
        this.isTTY = process.stdout.isTTY;
    }
    warn(message) {
        if (this.isTTY) {
            this.log((0, (_nodeEmoji || _load_nodeEmoji()).get)("warning") + "  " + (0, (_chalk || _load_chalk()).yellow)(message));
        } else {
            this.log((0, (_chalk || _load_chalk()).yellow)(`Warning: ${ message }`));
        }
    }
    log(message) {
        const text = `${ message }\n`;
        if (this.lines.length === 0) {
            this.stream.write(text);
        } else {
            this.lines.push(new SimpleLine(text));
            this.render();
        }
    }
    subTask(title, _promise) {
        if (!this.logTime) {
            return _promise;
        }
        return this.task(title, _promise);
    }
    task(title, _promise) {
        const promise = _promise;
        if (!this.logTime) {
            this.log(`${ title }\n`);
            return promise;
        }
        const task = new Task((0, (_chalk || _load_chalk()).blue)(title) + "\n", title, promise);
        this.lines.push(task);
        promise.then(() => {
            task.done();
            this.render();
        });
        this.render();
        return promise;
    }
    render() {
        const prevLineCount = this.lines.length;
        if (prevLineCount === 0) {
            (_cliCursor || _load_cliCursor()).show();
            return;
        }
        (_cliCursor || _load_cliCursor()).hide();
        let out = "";
        let firstPendingLineIndex = 0;
        while (firstPendingLineIndex < prevLineCount) {
            let line = this.lines[firstPendingLineIndex];
            if (line.promise == null || !line.promise.isPending()) {
                out += line.text;
                firstPendingLineIndex++;
            } else {
                break;
            }
        }
        if (firstPendingLineIndex > 0) {
            if (this.lines.length === firstPendingLineIndex) {
                this.lines.length = 0;
                this.stream.write((0, (_ansiEscapes || _load_ansiEscapes()).eraseLines)(prevLineCount) + out);
                (_cliCursor || _load_cliCursor()).show();
                return;
            }
            this.lines.splice(0, firstPendingLineIndex);
        }
        for (let line of this.lines) {
            out += line.text;
        }
        this.stream.write((0, (_ansiEscapes || _load_ansiEscapes()).eraseLines)(prevLineCount) + out);
    }
}
const logger = new Logger(process.stdout);
function warn(message) {
    logger.warn(message);
}
function log(message) {
    logger.log(message);
}
function subTask(title, promise) {
    return logger.subTask(title, promise);
}
function task(title, promise) {
    return logger.task(title, promise);
}
//# sourceMappingURL=log.js.map